<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/08/20/hello-world/"/>
    <url>/2025/08/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8.19 小测</title>
    <link href="/2025/08/19/8.19%E5%B0%8F%E6%B5%8B/"/>
    <url>/2025/08/19/8.19%E5%B0%8F%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="怀念逝去的-LaTeX"><a href="#怀念逝去的-LaTeX" class="headerlink" title="怀念逝去的 LaTeX"></a>怀念逝去的 LaTeX</h1><h2 id="T1-升序序列"><a href="#T1-升序序列" class="headerlink" title="T1 升序序列"></a>T1 升序序列</h2><p>简单来说，题目要求通过最少的操作次数（每次操作可以把某个数乘以2）让整个序列变成升序序列（非递减序列）。</p><p>由于使用贪心在处理后面的数时，会影响前面的决策，所以不能使用贪心解答这一题。</p><p><del>用惊人的注意力</del>注意到我们可以使用<strong>对每个数取对数</strong>的方法求出求出答案，这样乘法操作就变成了加法操作：log2 (a*2) &#x3D; log2(a) + 1，问题就转化为了通过最少的 +1 操作使对数序列成为非递减序列。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int unsigned long long int</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n,m,h;<br><span class="hljs-type">double</span> x,y;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        cin&gt;&gt;m;<br>        y=<span class="hljs-built_in">log2</span>(m);  <span class="hljs-comment">// 计算当前数字的以2为底的对数</span><br>        <span class="hljs-comment">// 如果前一个数的对数值大于当前数的对数值</span><br>        <span class="hljs-keyword">if</span>(x&gt;y)&#123;<br>            <span class="hljs-comment">// 计算需要乘以2的次数：ceil(x - y)，以及误差</span><br>            m=<span class="hljs-built_in">ceil</span>(x-y<span class="hljs-number">-1e-6</span>);<br>            h+=m,y+=m;<br>        &#125;<br>        x=y;  <span class="hljs-comment">// 更新前一个数的对数值为当前处理后的值</span><br>    &#125;<br>    cout&lt;&lt;h;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>？就只有一重循环，不就是 O(n) 吗</p><h2 id="T2-最大与求和"><a href="#T2-最大与求和" class="headerlink" title="T2 最大与求和"></a>T2 最大与求和</h2><p>简单来说，题目给出了一棵树（n 个点 n-1 条边的连通图），要求找出所有距离为 2 的点对，计算它们的权值乘积，然后找出最大的乘积和所有乘积的总和。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>再次使用惊人的注意力发现，如果两个点 u 和 v 距离为 2，那么它们之间一定存在一个中间点 w，使得 u-w 和 w-v 都有边相连。也就是说，u 和 v 都是 w 的直接邻居。那么，可以得出思路，<strong>对于每个点 w，可以考虑它的所有直接邻居之间的权值关系</strong></p><p>对于每个中间点w，假设它有k个邻居，权值分别为 $a_1,a_2,\dots,a_k$。那么这些邻居两两之间都会产生联合权值。</p><p>如果直接双重循环计算所有两两乘积，时间复杂度是 $O(k^2)$，最坏情况下可能会超时。</p><p>但是，我们知道，$(a_1 + a_2 + \dots + a_k)^2 &#x3D; {a_1}^2 + {a_2}^2 + \dots + {a_k}^2 + 2\times(a_1 a_2 + a_1a_3 + \dots + a_{k-1}a_k)$</p><p>所以，$(a_1 a_2 + a_1a_3 + \dots + a_{k-1}a_k)&#x3D;(a_1+a_2+\dots+a_k)^2&#x2F;2+({a_1}^2+{a_2}^2+\dots+{a_k}^2)&#x2F;2$</p><p>这样就能在 O(k) 时间内计算出所有两两乘积之和。</p><h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每个点遍历一次 +O(n)<br>每个点的邻居遍历一次（所有点的邻居总数等于边数的2倍） +2*(n-1)</p><p>O(n + 2 * (n-1) ) &#x3D; O(n)</p><h2 id="T3-子串"><a href="#T3-子串" class="headerlink" title="T3 子串"></a>T3 子串</h2><p>我是只能看懂一点，学完 Hash 之后第一眼看成 Hash 了（）</p><p>题目大概要处理两种操作，单点修改和区间查询，判断一个子串是否是排序后整个字符串的子串。</p><p>需要维护：<br>26个计数器，记录每个字母在整个字符串中的出现次数<br>26个数据结构，记录每个字母在哪些位置出现  </p><h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>区间查询以及更新点都需要 O(26 * log n)，有 Q 次查询，时间复杂度就是 O(26 * Q * log n)。</p><h2 id="T4-三色划分"><a href="#T4-三色划分" class="headerlink" title="T4 三色划分"></a>T4 三色划分</h2><p>题目要求将 n 个整数染成三种颜色，要求三种颜色的和能够构成三角形。</p><p><del>听完老师的课后，</del> 发现动态规划可以解决这个问题。</p><p>定义 dp[i][j][k] 表示考虑前i个数，红色和为j，绿色和为k时的方案数。对于每个数，有三种染色选择，最后统计所有满足三角形条件的(j, k, t-j-k)组合的方案数之和。</p><p>但是，由于三维 DP 占用的空间太大，可以使用滚动数组实现降维。</p><h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n*ai^2)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ST 表</title>
    <link href="/2025/08/14/ST%E8%A1%A8/"/>
    <url>/2025/08/14/ST%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="怀念逝去的-LaTeX"><a href="#怀念逝去的-LaTeX" class="headerlink" title="怀念逝去的 LaTeX"></a>怀念逝去的 LaTeX</h1><h1 id="ST-表基本概念"><a href="#ST-表基本概念" class="headerlink" title="ST 表基本概念"></a>ST 表基本概念</h1><p>ST 表（Sparse Table）是一种用于解决静态区间查询问题的数据结构，主要用于处理可重复贡献问题，比如区间最大值（RMQ）、区间最小值、区间 GCD 等。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>静态数据结构，建表后不能修改原始数据</li><li>预处理时间复杂度：O(n log n)</li><li>查询时间复杂度：O(1)</li></ul><h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><h3 id="1-预处理对数数组"><a href="#1-预处理对数数组" class="headerlink" title="1. 预处理对数数组"></a>1. 预处理对数数组</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">lg2[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>    lg2[i] = lg2[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个预处理可以在 O(1) 时间内找到任意区间长度对应的最大幂次。</p><h3 id="2-初始化-ST-表"><a href="#2-初始化-ST-表" class="headerlink" title="2. 初始化 ST 表"></a>2. 初始化 ST 表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>    st_max[i][<span class="hljs-number">0</span>] = arr[i];  <span class="hljs-comment">// 区间长度为 1 时的最大值就是元素本身</span><br>    st_min[i][<span class="hljs-number">0</span>] = arr[i];  <span class="hljs-comment">// 同理最小值</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-动态规划填充-ST-表"><a href="#3-动态规划填充-ST-表" class="headerlink" title="3. 动态规划填充 ST 表"></a>3. 动态规划填充 ST 表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">20</span>; j++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;<br>        st_max[i][j] = <span class="hljs-built_in">max</span>(st_max[i][j - <span class="hljs-number">1</span>], st_max[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        st_min[i][j] = <span class="hljs-built_in">min</span>(st_min[i][j - <span class="hljs-number">1</span>], st_min[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用倍增思想，每个状态 st[i][j] 表示从 i 开始，长度为 2^j 的区间的极值。</p><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p>查询区间 [l, r] 的最大值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_max</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = lg2[r - l + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 找到最大的 k 使得 2^k &lt;= 区间长度</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(st_max[l][k], st_max[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正确性原理"><a href="#正确性原理" class="headerlink" title="正确性原理"></a>正确性原理</h2><p>ST 表查询的正确性基于两个关键性质：</p><ol><li><p>区间覆盖性：</p><ul><li>对于任意区间 [l, r]，我们选择两个子区间 [l, l + 2^k - 1] 和 [r - 2^k + 1, r]</li><li>这两个子区间必定完全覆盖原区间 [l, r]</li><li>其中 k 是满足 2^k &lt;&#x3D; r - l + 1 的最大整数</li></ul></li><li><p>可重复贡献性：</p><ul><li>对于最大值运算 max，满足：<ul><li>max(a, a) &#x3D; a （幂等性）</li><li>max(a, b) &#x3D; max(b, a) （交换律）</li><li>max(a, max(b, c)) &#x3D; max(max(a, b), c) （结合律）</li></ul></li><li>这使得可以安全地计算重叠区间的最大值而不影响最终结果</li></ul></li></ol><h2 id="RMQ-模板代码"><a href="#RMQ-模板代码" class="headerlink" title="RMQ 模板代码"></a>RMQ 模板代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    lg2[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        lg2[i] = lg2[i / <span class="hljs-number">2</span>] + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">20</span>; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i + (<span class="hljs-number">1</span> &lt;&lt; j) - <span class="hljs-number">1</span> &lt;= n; i++) &#123;<br>            st[i][j] = <span class="hljs-built_in">min</span>(st[i][j - <span class="hljs-number">1</span>], st[i + (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>))][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-type">int</span> k = lg2[r - l + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(st[l][k], st[r - (<span class="hljs-number">1</span> &lt;&lt; k) + <span class="hljs-number">1</span>][k]);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>8.12 小测</title>
    <link href="/2025/08/12/8.12%E5%B0%8F%E6%B5%8B/"/>
    <url>/2025/08/12/8.12%E5%B0%8F%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="怀念逝去的-LaTeX"><a href="#怀念逝去的-LaTeX" class="headerlink" title="怀念逝去的 LaTeX"></a>怀念逝去的 LaTeX</h1><h2 id="T1-勇士"><a href="#T1-勇士" class="headerlink" title="T1 勇士"></a>T1 勇士</h2><p>勇士有 n 种武器，怪物初始有 x 个头，这些武器每次攻击减少怪物 d[i] 个头，之后怪物长出 h[i] 个头，目标是使怪物的头数 &lt;&#x3D; 0。</p><p>可以先计算计算武器的净伤害 d[i]-h[i]，优先使用净伤害最大的武器，然后使用 d[i] 最高的武器（要保证使用 d[i] 最高的武器后怪物的血量要 &lt;&#x3D; 0）。</p><p><del>显然可以不用数组的</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> d,h;<br>&#125;a[<span class="hljs-number">114</span>],b[<span class="hljs-number">114</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br><span class="hljs-keyword">return</span> (x.d-x.h)&gt;(y.d-y.h);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp2</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br><span class="hljs-keyword">return</span> x.d&gt;y.d;<br>&#125;<br><span class="hljs-type">int</span> n,x,t1,t2,sum;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;x;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i].d&gt;&gt;a[i].h,b[i].d=a[i].d,b[i].h=a[i].h;<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a<span class="hljs-number">+1</span>+n,cmp);<br><span class="hljs-built_in">sort</span>(b<span class="hljs-number">+1</span>,b<span class="hljs-number">+1</span>+n,cmp2);<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">1</span>].d-a[<span class="hljs-number">1</span>].h&lt;=<span class="hljs-number">0</span>&amp;&amp;b[<span class="hljs-number">1</span>].d&lt;x)&#123;<br>cout&lt;&lt;<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br><span class="hljs-keyword">if</span>(b[<span class="hljs-number">1</span>].d&gt;x) &#123;<br>cout&lt;&lt;sum<span class="hljs-number">+1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>sum++;<br>x-=a[<span class="hljs-number">1</span>].d;<br><span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>)&#123;<br>cout&lt;&lt;sum;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>x+=a[<span class="hljs-number">1</span>].h;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T2-星星点灯"><a href="#T2-星星点灯" class="headerlink" title="T2 星星点灯"></a>T2 星星点灯</h2><p>这题是最小生成树，目标是用最小代价点亮所有星星，可以通过两种方式点亮星星：</p><ol><li>直接点亮：花费固定代价 m</li><li>通过已点亮的星星间接点亮：花费 f[i][j]</li></ol><p>可以创建虚拟节点 0，连接所有星星，边权为 m，接着使用 Kruskal 算法，求最小生成树。</p><p>证明：</p><p>任意两星星间点亮路径唯一，且该路径上的最大边权被贪心过程最小化，且最小生成树的总权值 &#x3D; 点亮所有星星的最小代价。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>  <span class="hljs-type">int</span> from,to,val;<br>&#125;;<br>vector&lt;node&gt; edges;<br><span class="hljs-type">int</span> fa[<span class="hljs-number">2005</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <br>    <span class="hljs-keyword">return</span> fa[x]==x?x:fa[x]=<span class="hljs-built_in">find</span>(fa[x]); <br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(node x,node y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.val&lt;y.val;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;m,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=n;i++) fa[i] = i;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) edges.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-number">0</span>, i, m&#125;);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++) &#123;<br>            <span class="hljs-type">int</span> w;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;w);<br>            <span class="hljs-keyword">if</span>(w) edges.<span class="hljs-built_in">push_back</span>(&#123;i, j, w&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(edges.<span class="hljs-built_in">begin</span>(),edges.<span class="hljs-built_in">end</span>(),cmp);<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;e:edges)&#123;<br>        <span class="hljs-type">int</span> u=<span class="hljs-built_in">find</span>(e.from),v=<span class="hljs-built_in">find</span>(e.to);<br>        <span class="hljs-keyword">if</span>(u!=v) fa[u]=v,ans+=e.val;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="T3-蛋糕"><a href="#T3-蛋糕" class="headerlink" title="T3 蛋糕"></a>T3 蛋糕</h2><p>目标是用最少的切割次数得到总大小为 n 的蛋糕，但这个蛋糕很特别，所有蛋糕大小都是 2 的幂次方。</p><p>可以用二进制分解，统计每个 2^k 大小的蛋糕数量，接着按照贪心处理，从低位到高位，不足时向高位借位。</p><h2 id="T4-翘课计划"><a href="#T4-翘课计划" class="headerlink" title="T4 翘课计划"></a>T4 翘课计划</h2><p>要在最多翘 k 节课的情况下，最小化总停留在教室的时间。</p><p>由于小 C 每天必须从第一节课待到最后一节课，所以可以对每天计算翘不同数量课的最小停留时间，将每天作为一组物品，选择翘课策略。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>字符哈希</title>
    <link href="/2025/08/12/%E5%AD%97%E7%AC%A6%E5%93%88%E5%B8%8C/"/>
    <url>/2025/08/12/%E5%AD%97%E7%AC%A6%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="怀念逝去的-LaTeX"><a href="#怀念逝去的-LaTeX" class="headerlink" title="怀念逝去的 LaTeX"></a>怀念逝去的 LaTeX</h1><h2 id="字符串哈希理论"><a href="#字符串哈希理论" class="headerlink" title="字符串哈希理论"></a>字符串哈希理论</h2><p>哈希作用为快速比较两个子串是否相同（O(1) 时间复杂度）。</p><p>整体核心公式为：</p><p>Hash[i] &#x3D; ( Hash[i-1] * base + s[i] ) % mod</p><p>可以使用 <code>unsigned long long</code> 自然溢出这样就不需要求模。</p><p>哈希一般分为两种，一种是前缀哈希，一种是双哈希。</p><h3 id="前缀哈希"><a href="#前缀哈希" class="headerlink" title="前缀哈希"></a>前缀哈希</h3><p>前缀哈希是一种高效的字符串处理技术，主要用于快速计算任意子串的哈希值。</p><p>通过预处理字符串，构建一个前缀哈希数组，使得可以在 O(1) 时间内计算任意子串的哈希值。</p><p>对于字符串 s，前缀哈希的计算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">h[i]=(h[i<span class="hljs-number">-1</span>]*base+s[i])%mod;<br>p[i]=p[i<span class="hljs-number">-1</span>]*base%mod; <span class="hljs-comment">// 存储base的幂次</span><br></code></pre></td></tr></table></figure><p><strong>前缀哈希的实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> p 131 <span class="hljs-comment">// 进制基数，通常可以使用 131、13331</span></span><br><span class="hljs-type">int</span> Hash[<span class="hljs-number">100005</span>],p[<span class="hljs-number">100005</span>];<span class="hljs-comment">// h存储哈希值，p存储P的幂次</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(string s)</span></span>&#123;<br>p[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>Hash[i]=Hash[i<span class="hljs-number">-1</span>]*p+s[i<span class="hljs-number">-1</span>];<br>p[i]=p[i<span class="hljs-number">-1</span>]*p;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">如果不使用 unsigned long long，使用 long long，就不能让程序自然溢出，需要对数组进行取模。</span><br><span class="hljs-comment">*/</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l<span class="hljs-number">+1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h3><p>双哈希是一种用于解决哈希冲突的高级技术，比单一哈希更可靠。</p><p>双哈希能够能产生更均匀的探测序列，减少聚集现象，提供更好的分布特性。</p><p>双哈希使用两个不同的哈希函数来解决冲突：</p><ul><li>第一个哈希函数计算初始位置：<code>h1(key)</code></li><li>第二个哈希函数计算步长：<code>h2(key)</code></li><li>当发生冲突时，探测序列为：<code>(h1(key)+i*h2(key))%size</code>，其中 i 是尝试次数。</li></ul><p><strong>实现方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> p1 131</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> p2 13331</span><br><span class="hljs-type">int</span> h1[<span class="hljs-number">100005</span>],h2[<span class="hljs-number">100005</span>],pow1[<span class="hljs-number">100005</span>],pow2[<span class="hljs-number">100005</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(string s)</span></span>&#123;<br>pow1[<span class="hljs-number">0</span>]=pow2[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> len=s.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)&#123;<br>h1[i]=h1[i<span class="hljs-number">-1</span>]*p1+s[i<span class="hljs-number">-1</span>];<br>h2[i]=h2[i<span class="hljs-number">-1</span>]*p2+s[i<span class="hljs-number">-1</span>];<br>pow1[i]=pow1[i<span class="hljs-number">-1</span>]*p1;<br>pow2[i]=pow2[i<span class="hljs-number">-1</span>]*p2;<br>&#125;<br>&#125;<br><span class="hljs-function">pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_hash</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span>&#123;<br><span class="hljs-type">int</span> hash1=h1[r]-h1[l<span class="hljs-number">-1</span>]*pow1[r-l<span class="hljs-number">+1</span>];<br><span class="hljs-type">int</span> hash2=h2[r]-h2[l<span class="hljs-number">-1</span>]*pow2[r-l<span class="hljs-number">+1</span>];<br><span class="hljs-keyword">return</span> &#123;hash1,hash2&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>笔记</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
