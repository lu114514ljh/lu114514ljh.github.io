---
title: 字符哈希
date: 2025/8/12 20:56:11
tags: 
  - C++
  - 笔记
  - 算法
---
# 怀念逝去的 LaTeX

## 字符串哈希理论

哈希作用为快速比较两个子串是否相同（O(1) 时间复杂度）。

整体核心公式为：

Hash[i] = ( Hash[i-1] * base + s[i] ) % mod

可以使用 `unsigned long long` 自然溢出这样就不需要求模。

哈希一般分为两种，一种是前缀哈希，一种是双哈希。

### 前缀哈希

前缀哈希是一种高效的字符串处理技术，主要用于快速计算任意子串的哈希值。

通过预处理字符串，构建一个前缀哈希数组，使得可以在 O(1) 时间内计算任意子串的哈希值。

对于字符串 s，前缀哈希的计算：

```cpp
h[i]=(h[i-1]*base+s[i])%mod;
p[i]=p[i-1]*base%mod; // 存储base的幂次
```

**前缀哈希的实现**

```cpp
#define int unsigned long long
#define p 131 // 进制基数，通常可以使用 131、13331
int Hash[100005],p[100005];// h存储哈希值，p存储P的幂次
void init(string s){
	p[0]=1;
	int len=s.size();
	for(int i=1;i<=len;i++){
		Hash[i]=Hash[i-1]*p+s[i-1];
		p[i]=p[i-1]*p;
		/*
		如果不使用 unsigned long long，使用 long long，就不能让程序自然溢出，需要对数组进行取模。
		*/
	}
}
int get_hash(int l,int r){
	return h[r]-h[l-1]*p[r-l+1];
}
```

### 双哈希

双哈希是一种用于解决哈希冲突的高级技术，比单一哈希更可靠。

双哈希能够能产生更均匀的探测序列，减少聚集现象，提供更好的分布特性。

双哈希使用两个不同的哈希函数来解决冲突：

- 第一个哈希函数计算初始位置：`h1(key)`
- 第二个哈希函数计算步长：`h2(key)`
- 当发生冲突时，探测序列为：`(h1(key)+i*h2(key))%size`，其中 i 是尝试次数。

**实现方式**

```cpp
#define int unsigned long long
#define p1 131
#define p2 13331
int h1[100005],h2[100005],pow1[100005],pow2[100005];
void init(string s){
	pow1[0]=pow2[0]=1;
	int len=s.size();
	for(int i=1;i<=len;i++){
		h1[i]=h1[i-1]*p1+s[i-1];
		h2[i]=h2[i-1]*p2+s[i-1];
		pow1[i]=pow1[i-1]*p1;
		pow2[i]=pow2[i-1]*p2;
	}
}
pair<int,int> get_hash(int l,int r){
	int hash1=h1[r]-h1[l-1]*pow1[r-l+1];
	int hash2=h2[r]-h2[l-1]*pow2[r-l+1];
	return {hash1,hash2};
}
```




