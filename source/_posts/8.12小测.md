---
title: 8.12 小测
date: 2025/8/12 21:55:12
tags: 
  - C++
  - 小测
---
# 怀念逝去的 LaTeX

## T1 勇士

勇士有 n 种武器，怪物初始有 x 个头，这些武器每次攻击减少怪物 d[i] 个头，之后怪物长出 h[i] 个头，目标是使怪物的头数 <= 0。

可以先计算计算武器的净伤害 d[i]-h[i]，优先使用净伤害最大的武器，然后使用 d[i] 最高的武器（要保证使用 d[i] 最高的武器后怪物的血量要 <= 0）。

~~显然可以不用数组的~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
struct node{
	int d,h;
}a[114],b[114];
bool cmp(node x,node y){
	return (x.d-x.h)>(y.d-y.h);
}
bool cmp2(node x,node y){
	return x.d>y.d;
}
int n,x,t1,t2,sum;
signed main(){
	cin>>n>>x;
	for(int i=1;i<=n;i++) cin>>a[i].d>>a[i].h,b[i].d=a[i].d,b[i].h=a[i].h;
	sort(a+1,a+1+n,cmp);
	sort(b+1,b+1+n,cmp2);
	if(a[1].d-a[1].h<=0&&b[1].d<x){
		cout<<-1;
		return 0;
	}
	while(true){
		if(b[1].d>x) {
			cout<<sum+1;
			return 0;
		}
		sum++;
		x-=a[1].d;
		if(x<=0){
			cout<<sum;
			return 0;
		}
		x+=a[1].h;
	}
}
```

## T2 星星点灯

这题是最小生成树，目标是用最小代价点亮所有星星，可以通过两种方式点亮星星：

1. 直接点亮：花费固定代价 m
2. 通过已点亮的星星间接点亮：花费 f[i][j]

可以创建虚拟节点 0，连接所有星星，边权为 m，接着使用 Kruskal 算法，求最小生成树。

证明：

任意两星星间点亮路径唯一，且该路径上的最大边权被贪心过程最小化，且最小生成树的总权值 = 点亮所有星星的最小代价。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
  int from,to,val;
};
vector<node> edges;
int fa[2005];
int find(int x) { 
    return fa[x]==x?x:fa[x]=find(fa[x]); 
}
bool cmp(node x,node y){
    return x.val<y.val;
}
int main() {
    int m,n;
    scanf("%d%d",&m,&n);
    for(int i=0;i<=n;i++) fa[i] = i;
    for(int i=1;i<=n;i++) edges.push_back({0, i, m});
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=n;j++) {
            int w;
			scanf("%d", &w);
            if(w) edges.push_back({i, j, w});
        }
    }
    sort(edges.begin(),edges.end(),cmp);
    int ans=0;
    for(auto &e:edges){
        int u=find(e.from),v=find(e.to);
        if(u!=v) fa[u]=v,ans+=e.val;
    }
    printf("%d", ans);
    return 0;
}
```

## T3 蛋糕

目标是用最少的切割次数得到总大小为 n 的蛋糕，但这个蛋糕很特别，所有蛋糕大小都是 2 的幂次方。

可以用二进制分解，统计每个 2^k 大小的蛋糕数量，接着按照贪心处理，从低位到高位，不足时向高位借位。

## T4 翘课计划

要在最多翘 k 节课的情况下，最小化总停留在教室的时间。

由于小 C 每天必须从第一节课待到最后一节课，所以可以对每天计算翘不同数量课的最小停留时间，将每天作为一组物品，选择翘课策略。


