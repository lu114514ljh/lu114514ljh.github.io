---
title: 8.19 小测
date: 2025/8/19 20:32:02
---
# 怀念逝去的 LaTeX

## T1 升序序列
简单来说，题目要求通过最少的操作次数（每次操作可以把某个数乘以2）让整个序列变成升序序列（非递减序列）。

由于使用贪心在处理后面的数时，会影响前面的决策，所以不能使用贪心解答这一题。

~~用惊人的注意力~~注意到我们可以使用**对每个数取对数**的方法求出求出答案，这样乘法操作就变成了加法操作：log2 (a\*2) = log2(a) + 1，问题就转化为了通过最少的 +1 操作使对数序列成为非递减序列。

### 代码实现
```cpp
#include<bits/stdc++.h>
#define int unsigned long long int
using namespace std;
int n,m,h;
double x,y;
signed main(){
    cin>>n;
    while(n--){
        cin>>m;
        y=log2(m);  // 计算当前数字的以2为底的对数
        // 如果前一个数的对数值大于当前数的对数值
        if(x>y){
            // 计算需要乘以2的次数：ceil(x - y)，以及误差
            m=ceil(x-y-1e-6);
            h+=m,y+=m;
        }
        x=y;  // 更新前一个数的对数值为当前处理后的值
    }
    cout<<h;
    return 0;
}
```
### 时间复杂度
？就只有一重循环，不就是 O(n) 吗


## T2 最大与求和
简单来说，题目给出了一棵树（n 个点 n-1 条边的连通图），要求找出所有距离为 2 的点对，计算它们的权值乘积，然后找出最大的乘积和所有乘积的总和。
### 思路
再次使用惊人的注意力发现，如果两个点 u 和 v 距离为 2，那么它们之间一定存在一个中间点 w，使得 u-w 和 w-v 都有边相连。也就是说，u 和 v 都是 w 的直接邻居。那么，可以得出思路，**对于每个点 w，可以考虑它的所有直接邻居之间的权值关系**

对于每个中间点w，假设它有k个邻居，权值分别为 $a_1,a_2,\dots,a_k$。那么这些邻居两两之间都会产生联合权值。

如果直接双重循环计算所有两两乘积，时间复杂度是 $O(k^2)$，最坏情况下可能会超时。

但是，我们知道，$(a_1 + a_2 + \dots + a_k)^2 = {a_1}^2 + {a_2}^2 + \dots + {a_k}^2 + 2\times(a_1 a_2 + a_1a_3 + \dots + a_{k-1}a_k)$

所以，$(a_1 a_2 + a_1a_3 + \dots + a_{k-1}a_k)=(a_1+a_2+\dots+a_k)^2/2+({a_1}^2+{a_2}^2+\dots+{a_k}^2)/2$

这样就能在 O(k) 时间内计算出所有两两乘积之和。

### 时间复杂度
每个点遍历一次 +O(n)  
每个点的邻居遍历一次（所有点的邻居总数等于边数的2倍） +2*(n-1)

O(n + 2 * (n-1) ) = O(n)

## T3 子串
我是只能看懂一点，学完 Hash 之后第一眼看成 Hash 了（）

题目大概要处理两种操作，单点修改和区间查询，判断一个子串是否是排序后整个字符串的子串。

需要维护：  
26个计数器，记录每个字母在整个字符串中的出现次数  
26个数据结构，记录每个字母在哪些位置出现  

### 时间复杂度
区间查询以及更新点都需要 O(26 * log n)，有 Q 次查询，时间复杂度就是 O(26 * Q * log n)。

## T4 三色划分
题目要求将 n 个整数染成三种颜色，要求三种颜色的和能够构成三角形。

~~听完老师的课后，~~ 发现动态规划可以解决这个问题。

定义 dp[i][j][k] 表示考虑前i个数，红色和为j，绿色和为k时的方案数。对于每个数，有三种染色选择，最后统计所有满足三角形条件的(j, k, t-j-k)组合的方案数之和。

但是，由于三维 DP 占用的空间太大，可以使用滚动数组实现降维。

### 时间复杂度
O(n\*ai^2)